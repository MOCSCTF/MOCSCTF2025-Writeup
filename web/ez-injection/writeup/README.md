# ez_injection

## 题目描述

bkfish搭建了一個自以為十分安全的網站，但yulate卻不這麼想(^_^)

bkfish built a website that he thought was very secure, but yulate didn't think so(^_^)

## 题目类型

web安全

## 题目难度

3.5星

## 环境搭建

```
docker-compose up --build
```

然后访问localhost:9999即可

## 解题思路

直接访问页面，会显示签名验证失败，拒绝访问：

![QQ20250427-163733-1](.\img\QQ20250427-163733-1.png)

直接定位到代码的部分，可以发现签名的逻辑其实是判断你的请求头里是不是带了X-Signature字段，然后用这个字段解码后和$Secret_Key进行比较：

![QQ20250427-163943-2](.\img\QQ20250427-163943-2.png)

但这里的checkSignature函数以及verifySignature函数的验证配合存在一个严重的逻辑缺陷，checkSignature只是在能正常解码的时候把签名和$Secret_Key进行比较，返回真或者假，而verifySignature只有在checkSignature返回假的时候才退出，否则默认返回真，那么这里我们其实只需要构造一个错误的base64编码，比如@@@，让checkSignature解码错误，那么该函数就会抛出错误，且不会返回假，verifySignature也能正常通过：

```
GET / HTTP/1.1
Host: localhost:9999
X-Signature:@@@
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br
Connection: close
Upgrade-Insecure-Requests: 1
Priority: u=0, i
```

![QQ20250427-164555-3](.\img\QQ20250427-164555-3.png)

接着分析源码可以看出来，这个功能界面其实是有三个功能，后两个功能需要传入一个日期，而功能一什么也不需要传入：

![QQ20250427-164753-4](.\img\QQ20250427-164753-4.png)

这里index.php和execute.php通过构造的二进制协议进行传输，构造逻辑是：标志字段+命令长度+实际的命令

![QQ20250427-164833-5](.\img\QQ20250427-164833-5.png)

在execute.php中会首先判断来源是否是index.php，判断成功后对传入的二进制协议进行解析，若标志字段是A，直接执行命令，若标志字段是B，则会判断传入的命令是否是一个合法的日期格式，判断成功后拼接date -d进行执行，否则退出

![QQ20250427-164956-6](.\img\QQ20250427-164956-6.png)

这里我们本地抓一下查看日期的包，看一下二进制协议的构造细节：

![QQ20250427-165612-7](.\img\QQ20250427-165612-7.png)

可以看到传入的二进制数据是：

```
42000a323031322d31322d3131
```

其中42是B的十六进制，代表了这次协议的标志B，000a代表了这次请求载荷的长度是10，后面的323031322d31322d3131就是实际载荷2012-12-21

这里我们可以尝试恶意构造一个错误的数据，比如在2012-12-21后面加10个A，可以看到此时的长度就变成了0014，也就是20，这证明我们恶意构造一个比较长的数，这个长度字段确实会随之增长：

![QQ20250427-165952-8](.\img\QQ20250427-165952-8.png)

只不过后端这里存在校验，判断到你的标头是B，会用你的载荷对比是否是合法的日期，不是的话还是不能执行，除非标头是A才会直接执行，但我们并没有可控点：

![QQ20250427-170206-9](.\img\QQ20250427-170206-9.png)

但这里有一个很有趣的点，因为发送的长度字段是直接len的载荷，虽然我们的命令不符合日期可能不能直接执行，但我们现在确实能直接控制长度字段的长度。我们回看这个协议，这个 `pack('n', strlen($command))` 是什么意思呢？其实是获取`$command` 这段字符串的长度接着按照16位（2字节）无符号整数打包成二进制数据：

![QQ20250427-170445-10](.\img\QQ20250427-170445-10.png)

16位也就是我们之前看到的000a，而16位无符号整数其实有上限的，它的上限就是ffff，如果我们再给它加1，它就会变成10000，而经过16位的截断，实际上写入协议的长度就变成了0000。我们不妨做个实验，16位无符号整数的最大值是65536，而本来的载荷2012-12-11的长度是10，理论上我们只要再在2012-12-11的后面加65526个A，那么现在写入协议的长度字段就应该变成0000，而事实也正如我们所愿，它变成了0000：

![QQ20250427-171249-11](.\img\QQ20250427-171249-11.png)

尤里卡！现在我们已经能任意控制这个长度字段了，我们再回看后端解析协议的逻辑，它其实就是根据这个长度字段解析载荷，然后继续按着类似的逻辑解析下一个二进制协议，直到整个请求解析结束：

![QQ20250427-171444-12](.\img\QQ20250427-171444-12.png)

那么思路其实已经很明显了，因为只有标头为A的二进制协议才能正常执行，那么我们只需要构造一个标头为A的可以执行命令的二进制协议，将他放在2012-12-11的后面，然后填充A，保证第一个协议截断后恰好是一个合法的以A开头的协议，那么就会成功解析我们的协议并且执行任意命令了！

这里我们直接执行ls -al /，可以发现我们现在没有读取flag的权限，还需要提一下权：

![QQ20250427-172133-13](.\img\QQ20250427-172133-13.png)

这里我们用`find / -perm -u=s -type f 2>/dev/null`查一下suid，可以发现date存在suid提权的可能：

![QQ20250427-173508-18](.\img\QQ20250427-173508-18.png)

不过这里我们如果直接使用`date -f /f*`在页面上其实是看不到输出的：

![QQ20250427-172535-15](.\img\QQ20250427-172535-15.png)

回看网页代码里执行代码的逻辑，它其实是读取了缓冲区的结果进行输出，错误信息(我们的`date -f`执行得到的就是错误信息)通常会输出到标准错误流（`stderr`）中，而不会写入到标准输出流（`stdout`）中。

![QQ20250427-172617-16](.\img\QQ20250427-172617-16.png)

因此要想在页面上看到输出，我们需要把错误信息也输出到缓冲区，最后能打通的payload其实是`date -f /f* 2>&1`，不过再传POST的时候还需要对&特殊处理一下，否则解析会出错，比如我的exp.py里是直接base64了，最后我们终于可以读取flag了：
![QQ20250427-173057-17](.\img\QQ20250427-173057-17.png)
