## flag

MOCSCTF{y0U_AR3_a_gO0d_learN3er}

## 解題步驟

### 第一部分：直接給出一個質數因子

- **目標 FLAG 片段**: `MOCSCTF{` (對應整數 `m1`)
- **漏洞/特性**: RSA 的安全性依賴於大整數 N 難以分解。如果 N 的一個質數因子 p 被直接給出，則可以輕易計算出另一個因子 q，進而計算出私鑰 d。
- **設計思路**: 提供一個模數 `n1`，其一個質數因子 `p1g` (例如 256 比特) 會被直接告知參賽者。`q1` 可以是相同位數的另一個質數。
- **給予參賽者的參數**:
  - `n1 = <由腳本生成>`
  - `e1 = 65537`
  - `c1 = <由腳本生成>` (pow(m1, e1, n1))
  - `p1_given = <由腳本生成>` (n1 的一個質數因子)
- **預期解法**:
  1. 已知 `p1_given`。計算 `q1 = n1 // p1_given`。
  2. 計算歐拉函數 `phi1 = (p1_given - 1) * (q1 - 1)`。
  3. 計算私鑰 `d1 = pow(e1, -1, phi1)`。
  4. 解密得到 `m1 = pow(c1, d1, n1)`。
  5. `long_to_bytes(m1)` 得到 `MOCSCTF{`。

### 第二部分：N 由 p 和 next_prime(p) 構成

- **目標 FLAG 片段**: `y0U_AR3_` (對應整數 `m2`)
- **漏洞/特性**: 如果 N 由兩個非常接近的質數 `p` 和 `q` (例如 `q = next_prime(p)`) 相乘得到，那麼 `p` 和 `q` 都會非常接近 `sqrt(N)`。這使得 N 可以通過在 `sqrt(N)` 附近進行試除，或者使用費馬分解法 (Fermat's factorization method) 來分解。
- **設計思路**: `n2` 由一個質數 `p2` (例如 256 比特) 和緊隨其後的下一個質數 `q2 = gmpy2.next_prime(p2)` 相乘得到。
- **給予參賽者的參數**:
  - `n2 = <由腳本生成>`
  - `e2 = 65537`
  - `c2 = <由腳本生成>` (pow(m2, e2, n2))
- **預期解法**:
  1. 由於 `p2` 和 `q2` 非常接近 `sqrt(n2)`，可以從 `floor(sqrt(n2))` 開始向下（或向上）試除，以找到 `p2` (或 `q2`)。
  2. 或者使用費馬分解法：令 `a = ceil(sqrt(n2))`，檢查 `a^2 - n2` 是否為完全平方數 `b^2`。若是，則 `n2 = (a-b)(a+b)`，即 `p2 = a-b`, `q2 = a+b` (或反之)。
  3. 得到 `p2` 和 `q2` 後，計算 `phi2 = (p2 - 1) * (q2 - 1)`。
  4. 計算 `d2 = pow(e2, -1, phi2)`。
  5. 解密得到 `m2 = pow(c2, d2, n2)`。
  6. `long_to_bytes(m2)` 得到 `y0U_AR3_`。

### 第三部分：小公鑰指數攻擊

- **目標 FLAG 片段**: `a_gO0d_l` (對應整數 `m3`)
- **漏洞/特性**: 當公鑰指數 `e` 很小（例如 `e=3`），並且明文 `m` 相對較小，使得 `m^e < N` 時，密文 `c = m^e mod N` 就簡化為 `c = m^e`。此時，可以直接通過計算 `c` 的 `e` 次方根來恢復 `m`。
- **設計思路**:
  - `e3 = 3`。
  - 明文 `m3` 的位元長度應使得 `m3^3` 小於 `n3` 的位元長度。例如，如果 `m3` 是 60-70 比特，`m3^3` 約為 180-210 比特。
  - 模數 `n3` 選擇為例如 256 比特或更大，確保 `m3^3 < n3`。
- **給予參賽者的參數**:
  - `n3 = <由腳本生成>`
  - `e3 = 3`
  - `c3 = <由腳本生成>` (pow(m3, e3, n3)，由於 `m3^e3 < n3`，所以 `c3 = m3^e3`)
- **預期解法**:
  1. 確認 `e3` 很小 (為 3)。
  2. 計算 `m3_candidate = iroot(c3, e3)` (例如使用 `gmpy2.iroot(c3, 3)`).
  3. 驗證 `pow(m3_candidate, e3_val) == c3` (因為 `m3^e3 < n3`)。
  4. `long_to_bytes(m3_candidate)` 得到 `a_gO0d_l`。

### 第四部分：共模攻擊

- **目標 FLAG 片段**: `earN3er}` (對應整數 `m4`)

- **漏洞/特性**: 如果同一個明文 `m` 使用相同的模數 `N` 但不同的公鑰指數 `e_a` 和 `e_b` 進行加密，得到兩個密文 `c_a` 和 `c_b`，並且 `e_a` 和 `e_b` 互素，則可以恢復明文 `m`。

- **設計思路**:

  - 選擇一個模數 `n4` (例如 512 比特)。
  - 選擇兩個互素的公鑰指數 `e4a` (如 65537) 和 `e4b` (如 65539)。
  - 用這兩個指數分別加密明文 `m4`。

- **給予參賽者的參數**:

  - `n4 = <由腳本生成>` (公共模數)
  - `e4a = <由腳本生成, e.g., 65537>`
  - `c4a = <由腳本生成>` (pow(m4, e4a, n4))
  - `e4b = <由腳本生成, e.g., 65539>`
  - `c4b = <由腳本生成>` (pow(m4, e4b, n4))

- **預期解法**:

  1. 已知 `c4a = m4^e4a mod n4` 和 `c4b = m4^e4b mod n4`。

  2. 由於 `e4a` 和 `e4b` 互素，使用擴展歐几里得算法找到整數 `x` 和 `y` 使得 `e4a * x + e4b * y = gcd(e4a, e4b) = 1`。

  3. 那麼 `m4 = (c4a^x * c4b^y) mod n4`。

     - 注意：如果 `x` (或 `y`) 是負數，`c4a^x` 應該計算為 `(inv(c4a, n4))^{-x} mod n4`，其中 `inv(c4a, n4)` 是 `c4a` 對 `n4` 的模逆元。

  4. `long_to_bytes(m4)` 得到 `earN3er}`。

     